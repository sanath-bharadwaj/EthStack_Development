#// ----------------------------------------------------------------------------
#// COPYRIGHT RESERVED, 2007-2010, Robert Bosch GmbH. All rights reserved.  The
#/ reproduction, distribution and utilization of this document as well as the
#// communication of its contents to others without explicit authorization is
#// prohibited.  Offenders will be held liable for the payment of damages.  All
#// rights reserved in the event of the grant of a patent, utility model or
#// design.
#// ----------------------------------------------------------------------------
#//! \file
#//! \brief
#//!
#//! $Source: T $
#//! $Author:  $
#//! $Revision:  $
#//! $Date: ST $
#//!
#//! User documentation: doc Folder
#// ----------------------------------------------------------------------------
#// History:
#// ---------------------------------------------------------------------------
#######################################################################

#######################################################################
#
#Put the TestCase name below:

package TC_ETHSTD_SIM_UDP_RX;

#######################################################################

=head1 Test-Specification for TC_ETHSTD_SIM_UDP_RX

This is the test-specification as xml-describtion

<TestConfiguration>
 <TC_Id>TC_ETHSTD_SIM_UDP_RX</TC_Id>
 <TC_Spec>
  <BASDKey>$Name______:TC_ETHSTD_SIM_UDP_RX$$Class_____:PM$</BASDKey>
 </TC_Spec>
 <TC_BL>
  <BASDKey>$Variant___:AR41.18.0.0$$Revision__:0$</BASDKey>
 </TC_BL>
 <TC_EnvCond>BSWSim</TC_EnvCond>
 <TC_ExpRes>Passed</TC_ExpRes>
 <TestStep>TestCase is checking for something</TestStep>
 <TestMethod>Requirement based test</TestMethod>
 <TestPrep>Not Applicable</TestPrep>
 <TestType>automated</TestType>
 <Environment>Ethernet modules must be integrated and initialized</Environment>
 <ResConsumption>Not Applicable</ResConsumption>
 <CoveredReq_Id>BSW_FS_NET-2563
</CoveredReq_Id>
 <CoveredReq_Doc>some doc</CoveredReq_Doc>
</TestConfiguration>

=cut

#######################################################################

use STEPS_general;
use STEPS_DNCSIM;
use STEPS_NET;
use STEPS_NET_Reports;
use STEPS_BSWITF;
use STEPS_BSWITF_BSW;
use STEPS_BSWITF_ECU;
use STEPS_BSWITF_Debugger;
use STEPS_BSWITF_UTILS;
use EthSim_UTILS;


my (
	$TestResult,
	@OverallResults,
	$TestResultCounter
);

sub TC_set_parameters {
  #Here we can set initial parameters for the testcase
  return 1;
}

sub TC_initialization {
  BSWITF_Init();    ### Initialisation of the BSWITF
  NET_LOG_SetFileName($STEPS_config::STEPS_LOG_path.SNR_GetDNCSIMLogPath()."\\TC_ETHSTD_SIM_UDP_RX.txt");
  NET_Wait(8000);
  return 1;
}

sub PrepareEthernetFrame {

	## Prepare VLAN Header
	NET_CallFunction("EthSIM_PrepareVLANHeader","");


	#Prepare IPv4 Header
	NET_CallFunction("EthSIM_PrepareIpv4Header","");

	#Prepare UDP Header
	NET_CallFunction("EthSIM_PrepareUDPHeader","");

    #Prepare SoAd Header
	NET_CallFunction("EthSIM_PrepareSoAdHeader","");

}

sub TC_stimulation_and_measurement {
 	my $value;
  	my $RetVal;
  	my $TypeOfFrame;
  	my $Test_TxPdu_Id;
	my $Test_RxPdu_Id;

	my $Test_TotalRxFrameLen;
	my $Test_RxPayloadLen;
	my $Test_TxPayloadLen;

	S_w2log( 3, "\n1.	----------------- TC_ETHSTD_SIM_UDP_RX ----------------------------------\n","brown");
	S_w2log( 3, "\no SET	: Request FullCom at (ComMUserPerChannel_Eth_VLAN = 1) == (EthSMNetwork_VLAN = 0) ==  (EthIfController_0_CTRL0_TRCV0_VLAN_0x49 = 0).. \n", "brown");

	# START :  FULL COM SEQUENCES
  	#Select the mode FULL_COM
	NET_SetVariableRaw( "TestCDEthSim_ComMode" , 2);

	S_w2log( 3, "\n	o	SET	: Request FullCom of ComMChannel at EthSMNetwork ' VLAN' = 0. \n", "brown");
    my $idxNetwork = ETHSM_NETWORKID_VLAN_X49;
	# Request FULL_COM for selected EthSM Networks
	NET_CallFunction("TestCDEthSim_Trigger_ComMode",$idxNetwork );

  	NET_Wait(1000);

  	# Get the state of selected EthSM Network
  	S_w2log(3,"\n o	CHECK : Once the FULL_COM is requested , VLAN EthIf Controller shall come ONLINE  \n","brown");
	$RetVal = rba_SimEth_NET_UpdateResult( "VERDICT_PASS" , NET_CheckVariableRaw( "rbaSimEthStd_SM_Network_0_State" , ETHSM_STATE_ONLINE , ),"");

    # END : FULL COM SEQUENCE

    $Test_RxPdu_Id = 47;
    NET_SetVariableRaw("TestCDEthSim_ReqRxPduId",$Test_RxPdu_Id);

    S_w2log(3,"\no	SET	: Open the SoAd Socket for Communication \n","brown");
  	rba_SimEth_NET_UpdateResult(0, NET_CallFunction("EthSim_SoAd_SetUpSocConnection",sprintf("%x",$Test_RxPdu_Id)),"");
	rba_SimEth_NET_WaitCycles(2);

  	$Test_TotalRxFrameLen = 300;
  	$Test_RxPayloadLen	=	200;

  	NET_SetVariableRaw( "EthSim_RxPayloadLen", $Test_TotalRxFrameLen );
	NET_SetVariableRaw( "EthSim_RxPDU_Len", $Test_RxPayloadLen );

  	S_w2log(3,"\n o	SET : Prepare the Frame to be recieved by the ECU over ANY Socket \n","brown");
  	
  	
    
    NET_ETH_SetFrameField($Eth_FrameID,"ETH","DstMACaddr",$Target_mac);
  
    NET_ETH_SetFrameField($Eth_FrameID,"ETH","SrcMACaddr",$Source_mac);

    NET_ETH_SetFrameField($Eth_FrameID,"ETH","VLANEnabled",$Eth_Header->{'VlanEnabled'});
  
    if($Eth_VLANEnabled != 0)
  {
    NET_ETH_SetFrameField($Eth_FrameID,"ETH","VLANId", $Eth_Header->{'VlanId'});
  }

   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","Version","04");
    
   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","IHL","05");

   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","TOS","00");
    
   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","ECN", "00");

   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","TotalLength", $Ipv4_Len);
    
   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","Identification", "12,35");
 
   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","Flags","00");

   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","FragmentOffset", "00,00");

   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","TTL","01");
    
   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","Protocol",$IPv4_Header->{'Protocol'});

   #NET_ETH_SetFrameField($Eth_FrameID,"IPv4","HeaderChecksum","D8,42");

   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","SourceIPAddress", $IPv4_Header->{'Src_Address'});

   NET_ETH_SetFrameField($Eth_FrameID,"IPv4","DestinationIPAddress", $IPv4_Header->{'Dest_Address'});
  
   NET_ETH_SetFrameField($Eth_FrameID,"UDP","SourcePort", $UDP_Header->{'Src_Port'});

   NET_ETH_SetFrameField($Eth_FrameID,"UDP","DestinationPort", $UDP_Header->{'Dest_Port'});

   NET_ETH_SetFrameField($Eth_FrameID,"UDP","UDPLength", $Udp_Length);
   
   NET_ETH_SetFrameField($Eth_FrameID,"UDP","UDPPayload", $Udp_payload);


    NET_ETH_SetFrameField($Eth_FrameID,"ARP","ProtocolType","08,00");
    
    NET_ETH_SetFrameField($Eth_FrameID,"ARP","ProtocolAddLen","04");
    
    NET_ETH_SetFrameField($Eth_FrameID,"ARP","Operation",$Arp_Operation);
    
    NET_ETH_SetFrameField($Eth_FrameID,"ARP","SrcMACaddr",$Arp_SrcMACaddr);
    
    NET_ETH_SetFrameField($Eth_FrameID,"ARP","SrcIPaddr",$Arp_SrcIPaddr);
    
    NET_ETH_SetFrameField($Eth_FrameID,"ARP","DstMACaddr",$Arp_DstMACaddr);
    
    NET_ETH_SetFrameField($Eth_FrameID,"ARP","DstIPaddr",$Arp_DstIPaddr);
    

	if ($RetVal == 01)
	{
		S_w2log(3,"\no	INFO	: Data Reception on ANY socket successful -- VERDICT_PASS \n","green");
		NET_SetVariableRaw("UpperLayerRxIndication", CLEAR);
	}
	else
	{
		S_w2log(3,"\no	INFO	: Data Reception on ANY socket failed -- VERDICT_FAIL\n","red");
	}
	$Test_TxPayloadLen 	= 200;
	$Test_TxPdu_Id		= 3;

  	S_w2log(3,"\no	SET	: Once the Reception is successful , Initiate Transmission of TxPDU Id $Test_TxPdu_Id over the same ANY Socket. With pdulength = $Test_TxPayloadLen bytes. \n","brown");
 	#Select the Pdu Id on which  Transmission will be triggered from ECU
    NET_SetVariableRaw("TestCDEthSim_ReqTxPduId", $Test_TxPdu_Id );

	#Select Payload Length for the Tx Pdu
	NET_SetVariableRaw("TestCDEthSim_TxPduLen",$Test_TxPayloadLen);


    S_w2log(3,"\no	CHECK	: Transmission of UDP Frame over same socket \n","brown");
    rba_SimEth_NET_WaitCycles(2);

    S_w2log(3,"\no	CHECK	: validate the data is transmitted successfully or not \n","brown");
	$RetVal = rba_SimEth_NET_UpdateResult("VERDICT_PASS" , NET_CheckVariableRaw("Tranmission_Status", TRUE ,0) , "");
	if ($RetVal == 01)
	{
		S_w2log(3,"\no	INFO	: Data transmission on ANY socket successful -- VERDICT_PASS\n","green");
	}
	else
	{
		S_w2log(3,"\no	INFO	: Data transmission on ANY socket failed -- VERDICT_FAIL\n","red");
	}

  return 1;
}

#keep the below section common for all test cases
sub TC_evaluation {
	my $logbuffer;
	my $testnum = 1;
### overall result flags
	my ( $failed, $passed );
	EthSim_UTILS::rba_SimEth_NET_PrintTestStatus();

  return 1;
}

sub TC_finalization {
### exit the test environoment
  BSWITF_Exit();
  return 1;
}

1;
