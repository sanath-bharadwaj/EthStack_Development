#// ----------------------------------------------------------------------------
#// COPYRIGHT RESERVED, 2007-2010, Robert Bosch GmbH. All rights reserved.  The
#/ reproduction, distribution and utilization of this document as well as the
#// communication of its contents to others without explicit authorization is
#// prohibited.  Offenders will be held liable for the payment of damages.  All
#// rights reserved in the event of the grant of a patent, utility model or
#// design.
#// ----------------------------------------------------------------------------
#//! \file
#//! \brief
#//!
#//! $Source: T $
#//! $Author:  $
#//! $Revision:  $
#//! $Date: ST $
#//!
#//! User documentation: doc Folder
#// ----------------------------------------------------------------------------
#// History:
#// ---------------------------------------------------------------------------
#######################################################################

#######################################################################
#
#Put the TestCase name below:

package TC_ETHSTD_SIM_UDP_RX;

#######################################################################

=head1 Test-Specification for TC_ETHSTD_SIM_UDP_RX

This is the test-specification as xml-describtion

<TestConfiguration>
 <TC_Id>TC_ETHSTD_SIM_UDP_RX</TC_Id>
 <TC_Spec>
  <BASDKey>$Name______:TC_ETHSTD_SIM_UDP_RX$$Class_____:PM$</BASDKey>
 </TC_Spec>
 <TC_BL>
  <BASDKey>$Variant___:AR41.18.0.0$$Revision__:0$</BASDKey>
 </TC_BL>
 <TC_EnvCond>BSWSim</TC_EnvCond>
 <TC_ExpRes>Passed</TC_ExpRes>
 <TestStep>TestCase is checking for something</TestStep>
 <TestMethod>Requirement based test</TestMethod>
 <TestPrep>Not Applicable</TestPrep>
 <TestType>automated</TestType>
 <Environment>Ethernet modules must be integrated and initialized</Environment>
 <ResConsumption>Not Applicable</ResConsumption>
 <CoveredReq_Id>BSW_FS_NET-2563
</CoveredReq_Id>
 <CoveredReq_Doc>some doc</CoveredReq_Doc>
</TestConfiguration>

=cut

#######################################################################

use STEPS_general;
use STEPS_DNCSIM;
use STEPS_NET;
use STEPS_NET_Reports;
use STEPS_BSWITF;
use STEPS_BSWITF_BSW;
use STEPS_BSWITF_ECU;
use STEPS_BSWITF_Debugger;
#use strict;
#use warnings;
use STEPS_BSWITF_UTILS;
use EthSim_UTILS;
use rba_SimEthStd_Sd_Utils;
use rba_SimEth_TestLib;
use New_EthSim_UTILS;
use Data::Dumper;


my (
    $TestResult,
    @OverallResults,
    $TestResultCounter
);

sub TC_set_parameters {
  #Here we can set initial parameters for the testcase
  return 1;
}

sub TC_initialization {
  BSWITF_Init();    ### Initialisation of the BSWITF
  NET_LOG_SetFileName($STEPS_config::STEPS_LOG_path.SNR_GetDNCSIMLogPath()."\\TC_ETHSTD_SIM_UDP_RX.txt");
  NET_Wait(8000);
  return 1;
}

sub TC_stimulation_and_measurement {
    my $value;
    my $RetVal;
    my $TypeOfFrame;
    my $Test_TxPdu_Id;
    my $Test_RxPdu_Id;

    my $Test_TotalRxFrameLen;
    my $Test_RxPayloadLen;
    my $Test_TxPayloadLen;

    S_w2log( 3, "\n1.   ----------------- TC_ETHSTD_SIM_UDP_RX ----------------------------------\n","brown");
    S_w2log( 3, "\no SET    : Request FullCom at (ComMUserPerChannel_Eth_VLAN = 1) == (EthSMNetwork_VLAN = 0) ==  (EthIfController_0_CTRL0_TRCV0_VLAN_0x49 = 0).. \n", "brown");

    # START :  FULL COM SEQUENCES
    #Select the mode FULL_COM
    NET_SetVariableRaw( "TestCDEthSim_ComMode" , 2);

    S_w2log( 3, "\n o   SET : Request FullCom of ComMChannel at EthSMNetwork ' VLAN' = 0. \n", "brown");
    my $idxNetwork = ETHSM_NETWORKID_VLAN_X49;
    # Request FULL_COM for selected EthSM Networks
    NET_CallFunction("TestCDEthSim_Trigger_ComMode",$idxNetwork );

    NET_Wait(1000);

    # Get the state of selected EthSM Network
    S_w2log(3,"\n o CHECK : Once the FULL_COM is requested , VLAN EthIf Controller shall come ONLINE  \n","brown");
    $RetVal = rba_SimEth_NET_UpdateResult( "VERDICT_PASS" , NET_CheckVariableRaw( "rbaSimEthStd_SM_Network_0_State" , ETHSM_STATE_ONLINE , ),"");

    # END : FULL COM SEQUENCE








    $Test_RxPdu_Id = 47;
    
    Prepare_Frame_Fields(47);
    
    
    #NET_SetVariableRaw("TestCDEthSim_ReqRxPduId",$Test_RxPdu_Id);

    S_w2log(3,"\no  SET : Open the SoAd Socket for Communication \n","brown");
    rba_SimEth_NET_UpdateResult(0, NET_CallFunction("EthSim_SoAd_SetUpSocConnection",sprintf("%x",$Test_RxPdu_Id)),"");
    rba_SimEth_NET_WaitCycles(2);

    $Test_TotalRxFrameLen = 300;
    $Test_RxPayloadLen  =   200;

    NET_SetVariableRaw( "EthSim_RxPayloadLen", $Test_TotalRxFrameLen );
    NET_SetVariableRaw( "EthSim_RxPDU_Len", $Test_RxPayloadLen );

    S_w2log(3,"\n o SET : Prepare the Frame to be recieved by the ECU over ANY Socket \n","brown");

    # Prepare and Send UDP frame
    
     $Eth_FrameID="UDP_1";
    
     $Target_mac="FC,D6,BD,00,00,01";
     $Source_mac="44,37,E6,AC,E4,AC";
    
     #NET_CallFunction   ("TestCDEthSim_Proc","");
      #my   $temp_var_3 = pack "c",$Src_IpAddress_Byte1_Dec;
     #my  $Src_IpAddress_Byte1_Hex = unpack "H2", $temp_var_3;
    
    # Vlan Header
     #$Eth_VLANEnabled=1;
     #$EthVlanId=convertStringToHEXstring(NET_GetVariableRaw(TestCDEthSim_VLANId,""));
     $Ipv4_Len="00,E4";
     #$IPv4_Protocol=sprintf("%X",NET_GetVariableRaw(TestCDEthSim_Protocol,""));
     #print "$IPv4_Protocol";
     #$IPv4_Srcaddr="A0,30,C7,10";
     #$IPv4_Destaddr="A0,30,C7,19";


    
    # UDP Header
    
     #$Udp_Srcport="77,1A";
     #$Udp_Destport="77,7F";
     $Udp_Length="00,D0";
     $Udp_payload=C8;
     
     NET_Wait(20);
    
     rba_prepare_Eth_Header1();
     rba_prepare_Ipv4_Header2();
     rba_prepare_Udp_Header3();
     
    
    NET_Wait(20);
   
   
    NET_ETH_SendEthFrameById("UDP_1");
   
    NET_Wait(1);
   
    S_w2log(3,"\no  CHECK : Data is recieved till Upper layer \n","brown");
    $RetVal = rba_SimEth_NET_UpdateResult("VERDICT_PASS" , NET_CheckVariableRaw("UpperLayerRxIndication", TRUE ,0), "");

    if ($RetVal == 01)
    {
        S_w2log(3,"\no  INFO    : Data Reception on ANY socket successful -- VERDICT_PASS \n","green");
        NET_SetVariableRaw("UpperLayerRxIndication", CLEAR);
    }
    else
    {
        S_w2log(3,"\no  INFO    : Data Reception on ANY socket failed -- VERDICT_FAIL\n","red");
    }
    $Test_TxPayloadLen  = 200;
    $Test_TxPdu_Id      = 3;

    S_w2log(3,"\no  SET : Once the Reception is successful , Initiate Transmission of TxPDU Id $Test_TxPdu_Id over the same ANY Socket. With pdulength = $Test_TxPayloadLen bytes. \n","brown");
    #Select the Pdu Id on which  Transmission will be triggered from ECU
    NET_SetVariableRaw("TestCDEthSim_ReqTxPduId", $Test_TxPdu_Id );

    #Select Payload Length for the Tx Pdu
    NET_SetVariableRaw("TestCDEthSim_TxPduLen",$Test_TxPayloadLen);


    S_w2log(3,"\no  CHECK   : Transmission of UDP Frame over same socket \n","brown");
    rba_SimEth_NET_WaitCycles(2);

    S_w2log(3,"\no  CHECK   : validate the data is transmitted successfully or not \n","brown");
    $RetVal = rba_SimEth_NET_UpdateResult("VERDICT_PASS" , NET_CheckVariableRaw("Tranmission_Status", TRUE ,0) , "");
    if ($RetVal == 01)
    {
        S_w2log(3,"\no  INFO    : Data transmission on ANY socket successful -- VERDICT_PASS\n","green");
    }
    else
    {
        S_w2log(3,"\no  INFO    : Data transmission on ANY socket failed -- VERDICT_FAIL\n","red");
    }

  return 1;
}

sub convertStringToHEXstring()
{
    my $valuetobeConverted = shift;
    my $string;
    my @StoreArray;
    my $Conv_Stiched_result;
    
    
    $string = sprintf("%x",$valuetobeConverted),"\n";
    
    @StoreArray = $string =~ /../g;
    
    foreach(@StoreArray)
    {
       $Conv_Stiched_result .= ','.uc($_);
    
    }
    $Conv_Stiched_result =~ s/^\,//;
    
    return  $Conv_Stiched_result;
}


#keep the below section common for all test cases
sub TC_evaluation {
    my $logbuffer;
    my $testnum = 1;
### overall result flags
    my ( $failed, $passed );
    EthSim_UTILS::rba_SimEth_NET_PrintTestStatus();

  return 1;
}

sub TC_finalization {
### exit the test environoment
  BSWITF_Exit();
  return 1;
}

1;

